\documentclass[article,nojss]{jss}
%% NOTA BENE: More definitions --> further down
%%%%%%%%%%%%
%
\author{Martin M\"achler \\ ETH Zurich%
\\ April 2012 {\tiny (\LaTeX'ed \today)}%---- for now
}
\title{Accuractely Computing $\log(1 - \exp(-\abs{a}))$}
%% for pretty printing and a nice hypersummary also set:
\Plainauthor{Martin M\"achler} %% comma-separated
\Plaintitle{Accuractely Computing log(1 - exp(.))}
%
\SweaveOpts{engine=R,width=7,height=5,strip.white=true}

%% an abstract and keywords
\Abstract{
  ..... %% FIXME
}

\Keywords{R, MPFR, Rmpfr, Accuracy, Cancellation Error}
%% at least one keyword must be supplied

%% publication information
%% NOTE: Typically, this can be left commented and will be filled out by the technical editor
%% \Volume{13}
%% \Issue{9}
%% \Month{September}
%% \Year{2004}
%% \Submitdate{2004-09-29}
%% \Acceptdate{2004-09-29}

%% The address of (at least) one author should be given
%% in the following format:
\Address{
	Martin M\"achler\\
	Seminar f\"ur Statistik, HG G~16\\
	ETH Zurich\\
	8092 Zurich, Switzerland\\
	E-mail: \email{maechler@stat.math.ethz.ch}\\
	URL: \url{http://stat.ethz.ch/people/maechler}
}
%% It is also possible to add a telephone and fax number
%% before the e-mail in the following format:
%% Telephone: +43/1/31336-5053
%% Fax: +43/1/31336-734

%% for those who use Sweave please include the following line (with % symbols):
%% MM: this is "substituted" by  jss.cls:
%% need no \usepackage{Sweave.sty}

\usepackage[american]{babel}%for American English
\usepackage{amsmath}%sophisticated mathematical formulas with amstex (includes \text{})
\usepackage{mathtools}%fix amsmath deficiencies
\usepackage{amssymb}%sophisticated mathematical symbols with amstex (includes \mathbb{})
% \usepackage{amsthm}%theorem environments
\usepackage{bm}%for bold math symbols: \bm (= bold math)
\usepackage{enumitem}%for automatic numbering of new enumerate environments

% This is already in jss above -- but withOUT the  fontsize=\small part !!
\DefineVerbatimEnvironment{Sinput}{Verbatim}{fontsize=\small,fontshape=sl}
\DefineVerbatimEnvironment{Soutput}{Verbatim}{fontsize=\small}
\DefineVerbatimEnvironment{Scode}{Verbatim}{fontsize=\small,fontshape=sl}
%% makes space between Sinput and Soutput smaller:
\fvset{listparameters={\setlength{\topsep}{0pt}}}% !! quite an effect!
%% ??? FIXME but it also influences all other lists, itemize, ... ???? FIXME
%%
\setkeys{Gin}{width=\textwidth}% Sweave.sty has {width=0.8\textwidth}

\newcommand*{\R}{\proglang{R}}%{\textsf{R}}
\newcommand*{\CRANpkg}[1]{\href{http://CRAN.R-project.org/package=#1}{\pkg{#1}}}

\newcommand*{\eps}{\varepsilon}
%- \abs{ab}  -->  | ab |   ``absolut Betrag''
        \newcommand{\abs}[1]    {\left| #1 \right|}
% \renewcommand*{\S}{\operatorname*{S}}
% \newcommand*{\tS}{\operatorname*{\tilde{S}}}
% \newcommand*{\ran}{\operatorname*{ran}}
%\newcommand*{\sgn}{\operatorname*{sgn}}
\DeclareMathOperator{\sign}{sign}
% \renewcommand*{\L}{\mathcal{L}}
% \newcommand*{\Li}{\mathcal{L}^{-1}}
% \newcommand*{\LS}{\mathcal{LS}}
% \newcommand*{\LSi}{\LS^{-1}}
\newcommand{\tr}{\ensuremath{^\mathsf{T}}}% or  ^{\intercal}
\renewcommand*{\O}{\mathcal{O}}
% \newcommand*{\Geo}{\operatorname*{Geo}}
% \newcommand*{\Exp}{\operatorname*{Exp}}
% \newcommand*{\Sibuya}{\operatorname*{Sibuya}}
% \newcommand*{\Log}{\operatorname*{Log}}
% \newcommand*{\U}{\operatorname*{U}}
% \newcommand*{\B}{\operatorname*{B}}
% \newcommand*{\NB}{\operatorname*{NB}}
% \newcommand*{\N}{\operatorname*{N}}
\DeclareMathOperator{\var}{var}
\DeclareMathOperator{\Var}{Var}
\DeclareMathOperator{\Cov}{Cov}
\DeclareMathOperator{\cov}{cov}
\DeclareMathOperator{\Cor}{Corr}
\DeclareMathOperator{\cor}{corr}
% \newcommand*{\Var}{\operatorname*{Var}}
% \newcommand*{\Cov}{\operatorname*{Cov}}
% \newcommand*{\Cor}{\operatorname*{Cor}}
%
% \newcommand*{\loglp}{\operatorname*{log1p}}
% \newcommand*{\expml}{\operatorname*{expm1}}
%% cannot use "1" in latex macro name -- use "l":
\newcommand*{\loglp}{\mathrm{log1p}}
\newcommand*{\expml}{\mathrm{expm1}}

%% journal specific aliases
\newcommand*{\setcapwidth}[1]{}

%% end of declarations %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{document}
%% include your article here, just as usual
%% Note that you should use the \pkg{}, \proglang{} and \code{} commands.
% \section[About Java]{About \proglang{Java}}
%% Note: If there is markup in \(sub)section, then it has to be escape as above.
%% Note: These are explained in '?RweaveLatex' :
<<preliminaries, echo=FALSE, results=hide>>=
op.orig <-
options(width = 75,
        SweaveHooks= list(fig=function() par(mar=c(5.1, 4.1, 1.1, 2.1))),
        useFancyQuotes = FALSE,
        ## for JSS, but otherwise MM does not like it:
        ## prompt="R> ",
        continue="  ")# 2 (or 3) blanks: use same length as 'prompt'

if((p <- "package:fortunes") %in% search())
    try(detach(p, unload=TRUE, char=TRUE))
Sys.setenv(LANGUAGE = "en")
if(.Platform$OS.type != "windows")
  Sys.setlocale("LC_MESSAGES","C")
library("sfsmisc")# e.g., for eaxis()
.plot.BC <- FALSE # no Box-Cox plot
@
%\section[Introduction]{Introduction \small~\footnote{\mythanks}}
\section{Introduction: Not log() nor exp(), but log1p() and expm1()}

In applied mathematics, it has been known for a very long time, that direct
computation of $\log(1 + x)$ suffers from severe cancellation (in ``$1 +
x$'') whenever $\abs{x} \ll 1$, and for that reason, we have provided
\code{log1p(x)} in \R{}, since R version 1.0.0 (released, Feb.~29, 2000). Similarly,
\code{log1p()} has been provided by C math libraries and become part of C
language standards around the same time.

Analogously, since \R{} 1.5.0 (April 2002), the function \code{expm1(x)}
computes $\exp(x) - 1 = e^x - 1$ accurately also for $\abs{x} \ll 1$, where $e^x
\approx 1$ is (partially) cancelled by ``$-\: 1$''.

In both cases, a simple approach is to use a few terms of the Taylor series
for small $\abs{x}$, as
\begin{align}
  \label{eq:Taylor-log1p}
  \loglp(x) &= \log(1 + x) = x - x^2/2 + x^3/3 -+ \dots,
  \ \mathrm{for}\ \ \abs{x} < 1,
\mathrm{and}\\
  \label{eq:Taylor-expm1}
  \expml(x) &= \exp(x) - 1 = x + x^2/2! + x^3/3! + \dots,
  \ \mathrm{for}\ \ \abs{x} < 1,
\end{align}
and $n! = n(n-1)\cdots 1$ is the usual factorial notation.

We have found, however, that in some situations, the use of $\loglp()$ and
$\expml()$ may not be sufficient to prevent loss of numerical accuracy.
The topic of this note is to analyze the important case of computing
$\log\left(1 - e^x \right) = \log(1 - \exp(x))$ for $x < 0$.

\section{log1p() and expm1() for log(1 - exp(x))}
Contrary to expectation, for computing
$\log\left(1 - e^x \right) = \log(1 - \exp(x))$ for $x < 0$, neither
\begin{align}
  \label{eq:f.log1p}
  \log(1 - \exp(x)) &= \loglp(-\exp(x)), \ \ \mathrm{nor}\\
  \label{eq:f.expm1}
  \log(1 - \exp(x)) &= \log(-\expml(x)),
\end{align}
are uniformly sufficient for numerical evaluation.
To show this, we make use of the \R{} package \CRANpkg{Rmpfr} for arbitrarily
accurate numerical computation, and use the following simple functions:
<<def-test-funs>>=
library(Rmpfr)

t3.l1e <- function(a)
{
    c(def   = log(1 - exp(-a)),
      expm1 = log( -expm1(-a)),
      log1p = log1p(-exp(-a)))
}
leg <- local({ r <- body(t3.l1e)[[2]]; r[[1]] <- `expression`; eval(r) })
leg ## will be used below

relE.l1e <- function(a, precBits = 1024) {
    stopifnot(is.numeric(a), length(a) == 1, precBits > 50)
    da <- t3.l1e(a)  ## double precision
    a. <- mpfr(a, precBits=precBits)
    Ma <- t3.l1e(a.) ## multi.precision
    mMa <- median(Ma)
    structure(as.numeric(1 - da/mMa), names = names(da))
}
@
where the last one, \code{relE.l1e()} computes the relative error of three
different ways to compute  $\log(1 - \exp(-a))$ for positive $a$
(instead of computing   $\log(1 - \exp(x))$ for negative $x$).

%% FIXME "cache = TRUE": ---
<<comp-big>>=
a.s <- 2^seq(-55,10, length = 256)
ra.s <- t(sapply(a.s, relE.l1e))
@
<<bigpic-show, eval=FALSE>>=
cbind(a.s, ra.s)
@
<<bigpic-do, echo=FALSE>>=
capture.and.write(cbind(a.s, ra.s), 8, last = 6)
@
This is really revealing: both methods, log1p, and expm1, are not uniformly good enough.
Note that for large $a$, the relative errors evaluate to \code{NaN}. This
is because all three double precision methods give 0, \emph{and} that is
the best approximation in double precision, hence no problem at all,
and we can restrict ourselves to smaller $a$, i.e., $a < \approx 710$, here.

What about really small $a$'s?
<<a.small>>=
t3.l1e(1e-20)
as.numeric(t3.l1e(mpfr(1e-20, 256)))
@
% ##    expm1      def    log1p
% ## -46.0517     -Inf     -Inf
% as.numeric():
% ## [1] -46.0517 -46.0517 -46.0517
so, indeed,  the \code{expm1} method is absolutely needed here.

%% FIXME "cache = TRUE": ---
%% do not show here, we need the region for adding to the plot:
<<zoomin-comp, echo=FALSE>>=
a. <- (1:400)/256
ra <- t(sapply(a., relE.l1e))
ra2 <- ra[,-1]
@

%% --- Define figure_1 here ------------------------------
%% main = "|relative errors| of three methods for log(1 - exp(-a))"
<<bigpict-def, eval=FALSE>>=
matplot(a.s, abs(ra.s), type = "l", log = "xy", col = (cc <- c(4,1,2)),
        xlab = "a", ylab = "", axes=FALSE)
legend("top", leg, col=cc, lty=1:3, bty="n")
draw.machEps <- function(alpha.f = 1/3, col = adjustcolor("black", alpha.f)) {
    abline(h = .Machine$double.eps, col=col, lty=3)
    axis(4, at=.Machine$double.eps, label=quote(epsilon[c]), las=1, col.axis=col)
}
eaxis(1); eaxis(2); draw.machEps(0.4)
@

Now, we zoom in the region where both methods are about of the same (good) accuracy.
<<zoomin-show, eval=FALSE>>=
<<zoomin-comp>>
@

<<draw-zoomin, eval=FALSE, echo=FALSE>>=
## draw the zoom-in region into the plot:
yl <- range(pmax(1e-18, abs(ra2)))
rect(min(a.), yl[1], max(a.), yl[2],
     col= adjustcolor("black", .05), border="gray", pch = 5)
@

\begin{figure}[hbp!]
\centering
<<bigpict-fig, fig=TRUE, echo=FALSE>>=
<<bigpict-def>>
<<draw-zoomin>>
@
\setcapwidth{\textwidth}%
  \caption{Absolute relative errors (with respect to 1024 bit \pkg{Rmpfr}
    computation) of the default $\log(1 - e^{-a})$ the two methods
    ``\code{expm1}'' $\log(-\expml(-a))$ and ``\code{log1p}'' $\loglp(-\exp(-a))$.
    Note that the default basically gives the maximum of the two methods' errors,
    whereas the final \code{log1mexp()} function will have the minimum
    (approximately) of the two. \ \
    Figure~\ref{fig:zoomin-pic} will be a zoom into the gray rectangular region
    where all three curves are close.}
  \label{fig:bigpic}
\end{figure}

Because we want to smooth the two accuracy curves, but have noticed that
neither smoothing the original, nor the log-transformed values seems ok, as
the errors are asymmetric in both cases,
we use  \code{MASS::boxcox()} to determine the ``correct'' power transformation,
<<boxcox>>=
da <- cbind(a = a., as.data.frame(ra2))
library(MASS)
bc1 <- boxcox(abs(expm1) ~ a, data = da, lambda = seq(0,1, by=.01), plotit=.plot.BC)
bc2 <- boxcox(abs(log1p) ~ a, data = da, lambda = seq(0,1, by=.01), plotit=.plot.BC)
c(with(bc1, x[which.max(y)]),
  with(bc2, x[which.max(y)]))## optimal powers 0.38 and 0.30 ==> taking 1/3 :
s1 <- with(da, smooth.spline(a, abs(expm1)^(1/3), df = 10))
s2 <- with(da, smooth.spline(a, abs(log1p)^(1/3), df = 10))
@
and now plot a ``zoom -- in'' of the previous accuracy graphic,
already suggesting, that the cutoff, $a_0 = \log(2)$ is empirically very close to
optimal:
<<zoom-in-def-0, eval=FALSE, echo=FALSE>>=
cl2 <- "slateblue" # "gray35" # the color for "log(2)"
opal <- palette("default"); palette(adjustcolor(palette(), 0.6))
<<zoom-in-def-1, eval=FALSE>>=
matplot(a., abs(ra2), type = "l", log = "y", # ylim = c(-1,1)*1e-12,
        ylim = yl, xlab = "a", ylab = "", axes=FALSE)
legend("topright", leg[-1], col=1:3, lty=1:3, bty="n")
eaxis(1); eaxis(2); draw.machEps()
lines(a., predict(s1)$y ^ 3,               lwd=2)
lines(a., predict(s2)$y ^ 3, col=2, lty=2, lwd=2)
@
<<zoom-in-def-2, eval=FALSE,echo=FALSE>>=
abline(v = log(2), col = cl2, lty=4)
axis(1, at=log(2), label=quote(log(2)), las=1, col.axis=cl2, col=cl2, lty=4)
palette(opal)
## what system is it ?
sysInf <- Sys.info()[c("sysname", "release", "nodename", "machine")]
mtext(with(as.list(sysInf),
           paste0(sysname," ",release,"(",nodename,") -- ", machine)),
      side=1, adj=1, line=2.25, cex = 3/4)
@
%% no title here: main = "|relative errors| of two methods for log(1 - exp(-a))")
%
\enlargethispage{3ex}
\begin{figure}[hb!]
\centering
<<zoom-in-fig, fig=TRUE, height=6, width=8.8, echo=FALSE>>=
<<zoom-in-def-0>>
<<zoom-in-def-1>>
<<zoom-in-def-2>>
@
\setcapwidth{\textwidth}%
  \caption{a ``zoom in'' of Figure~\ref{fig:bigpic} showing the region
    where the two basic methods, ``\code{expm1}'' and ``\code{log1p}'' switch their
    optimality with respect to their relative errors.  Both have small
    relative errors in this region, typically below $\eps_c :=$%
    \code{.Machine\$double.eps}$=2^{-52} \approx 2.22\cdot 10^{-16}$.
    \ \
    The smoothed curves indicate crossover very close to $a = a_0 := \log(2)$.}
  \label{fig:zoomin-pic}
\end{figure}

\paragraph{Why is it very plausible to take $a_0 := \log(2)$ as approximately optimal cutoff?}

Already from Figure~\ref{fig:zoomin-pic}, empirically, an optimal cutoff $a_0$ is
around $0.7$.
We propose to compute
\begin{align}
  \label{eq:def-log1mexp}
  f(a) = \log\left(1 - e^{-a}\right) = \log(1 - \exp(-a)),
\end{align}
by a new method or function \code{log1mexp(a)}.
It needs a cutoff $a_0$ between choosing
\code{expm1} for $a \le a_0$  and
\code{log1p} for $a > a_0$, i.e.,
\begin{align}
  \label{eq:log1mexp}
  \mathrm{log1mexp}(a) :=
  \begin{cases}
    \log(-\expml(-a))  & a \le a_0  \ \ ( := \log(2) \approx 0.693) \\
    \loglp(-\exp(-a))  & a  >  a_0.
  \end{cases}
\end{align}


\subsection*{Session Information}

<<sessionInfo, results=tex>>=
toLatex(sessionInfo())
<<finalizing, echo=FALSE>>=
options(op.orig)
@

\end{document}
