
R version 2.8.1 RC (2008-12-15 r47212)
Copyright (C) 2008 The R Foundation for Statistical Computing
ISBN 3-900051-07-0

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> stopifnot(require("Rmpfr"))
Loading required package: Rmpfr
Loading C code of R package 'Rmpfr': GMP using 32 bits per limb

Attaching package: 'Rmpfr'


	The following object(s) are masked from package:stats :

	 pnorm 

> 
> ### Try to look at the internal bit-representation of the limbs
> 
> .limbs <- function(x) {
+     stopifnot(is(x, "mpfr"))
+     lapply(x, slot, "d") # not sapply() each can have different prec. & #{limbs}
+ }
> .expo <- function(x) {
+     stopifnot(is(x, "mpfr"))
+     sapply(x, slot, "exp")
+ }
> 
> Bits <- function(x) {
+     L <- .limbs(x)# list(length n) each of "k(prec)" 32-bit ints
+     hasNA <- any(iNA <- sapply(lapply(L, is.na), any)) # iNA: TRUE if there's an NA
+     ## need to catch them later
+     CC <- function(ch) paste(ch, collapse="")
+     hex <- sapply(L, function(I) CC(sprintf("%x", rev(I))))
+     if(hasNA) hex[iNA] <- NA_character_
+     hex <- strsplit(hex, NULL)
+ 
+     db <- t(expand.grid(0:1,0:1,0:1,0:1, KEEP.OUT.ATTRS=FALSE)[,4:1])
+     storage.mode(db) <- "character" # "0" or "1"
+     dimnames(db) <- list(NULL, c(paste(0:9), letters[1:6]))
+     ## db is  4 x 16  matrix  with col.names "0" "1" .. "9" "a" "b" ... "f"
+ 
+     ex <- .expo(x)
+     if(is.matrix(ex))
+         ## 64-bit case: exponent is long == two ints
+         ## -----------  but currently the 2nd int is always 0 (or NA for '0')
+         ex <- ex[1,]
+     pat <- paste("(", sapply(pmax(0, ex),
+                              function(n) CC(rep.int(".", n))),
+                  ")0+$", sep="")
+     pat <- ifelse(iNA, NA_character_, pat)
+ 
+     if(hasNA) {
+ 	r <- as.list(iNA)
+ 	r[!iNA] <- lapply(hex[!iNA], function(ch) CC(as.vector(db[,ch])))
+ 	r[iNA ] <- NA_character_
+         ## now keep correct number of trailing zeros :
+         r[!iNA] <- lapply(which(!iNA), function(i) sub(pat[i], "\\1", r[[i]]))
+         unlist(r)
+     }
+     else {
+ 	r <- lapply(hex, function(ch) CC(as.vector(db[,ch])))
+         ## now keep correct number of trailing zeros :
+         sapply(seq_along(r), function(i) sub(pat[i], "\\1", r[[i]]))
+     }
+ 
+ }
> 
> x <- mpfr(c(3:5,11:15, 59, 125:127, 1025), 64)
> x
13 'mpfr' numbers of precision  64   bits 
 [1] 3.00000000000000000000   4.00000000000000000000   5.00000000000000000000  
 [4] 1.10000000000000000000e1 1.20000000000000000000e1 1.30000000000000000000e1
 [7] 1.40000000000000000000e1 1.50000000000000000000e1 5.90000000000000000000e1
[10] 1.25000000000000000000e2 1.26000000000000000000e2 1.27000000000000000000e2
[13] 1.02500000000000000000e3
> data.frame(x= as.numeric(x), I(Bits(x)))
      x     Bits.x.
1     3          11
2     4        <NA>
3     5         101
4    11        1011
5    12        1100
6    13        1101
7    14        1110
8    15        1111
9    59      111011
10  125     1111101
11  126     1111110
12  127     1111111
13 1025 10000000001
> 
> x <- mpfr(c(-20:30),64)
> data.frame(x= as.numeric(x), I(Bits(x)))
     x Bits.x.
1  -20   10100
2  -19   10011
3  -18   10010
4  -17   10001
5  -16    <NA>
6  -15    1111
7  -14    1110
8  -13    1101
9  -12    1100
10 -11    1011
11 -10    1010
12  -9    1001
13  -8    <NA>
14  -7     111
15  -6     110
16  -5     101
17  -4    <NA>
18  -3      11
19  -2    <NA>
20  -1    <NA>
21   0    <NA>
22   1    <NA>
23   2    <NA>
24   3      11
25   4    <NA>
26   5     101
27   6     110
28   7     111
29   8    <NA>
30   9    1001
31  10    1010
32  11    1011
33  12    1100
34  13    1101
35  14    1110
36  15    1111
37  16    <NA>
38  17   10001
39  18   10010
40  19   10011
41  20   10100
42  21   10101
43  22   10110
44  23   10111
45  24   11000
46  25   11001
47  26   11010
48  27   11011
49  28   11100
50  29   11101
51  30   11110
> 
> ## pi, in varying number of bits :
> p. <- round(pi* 2^c(10,16,5*(4:8)))
> dput(p.)
c(3217, 205887, 3294199, 105414357, 3373259426, 107944301636, 
3454217652358)
> p <- c(mpfr(c(3217, 205887, 3294199, 105414357,
+               3373259426, 107944301636, 3454217652358), 64),
+        Const("pi", 64))
> Bits(p)
[1] "110010010001"                                                    
[2] "110010010000111111"                                              
[3] "1100100100001111110111"                                          
[4] "110010010000111111011010101"                                     
[5] "11001001000011111101101010100010"                                
[6] "1100100100001111110110101010001000100"                           
[7] "110010010000111111011010101000100010000110"                      
[8] "1100100100001111110110101010001000100001011010001100001000110101"
> 
> 
> cat('Time elapsed: ', proc.time(),'\n') # "stats"
Time elapsed:  0.664 0.039 0.746 0 0 
> 
> if(!interactive()) warnings()
NULL
> 
