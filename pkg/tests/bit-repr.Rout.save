
R version 2.14.2 beta (2012-02-19 r58418)
Copyright (C) 2012 The R Foundation for Statistical Computing
ISBN 3-900051-07-0
Platform: x86_64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> stopifnot(require("Rmpfr"))
Loading required package: Rmpfr
Loading required package: gmp

Attaching package: 'gmp'

The following object(s) are masked from 'package:base':

    %*%, apply, crossprod, matrix, tcrossprod

Loading C code of R package 'Rmpfr': GMP using 64 bits per limb

Attaching package: 'Rmpfr'

The following object(s) are masked from 'package:stats':

    pnorm, print.integrate

The following object(s) are masked from 'package:base':

    cbind, pmax, pmin, rbind

> 
> ### Try to look at the internal bit-representation of the limbs
> 
> .limbs <- function(x) {
+     stopifnot(is(x, "mpfr"))
+     lapply(x@.Data, slot, "d") # not sapply() each can have different prec. & #{limbs}
+ }
> .expo <- function(x) {
+     stopifnot(is(x, "mpfr"))
+     sapply(x@.Data, slot, "exp")
+ }
> 
> Bits <- function(x) {
+     L <- .limbs(x)# list(length n) each of "k(prec)" 32-bit ints
+     hasNA <- any(iNA <- sapply(lapply(L, is.na), any)) # iNA: TRUE if there's an NA
+     ## need to catch them later
+     CC <- function(ch) paste(ch, collapse="")
+     hex <- sapply(L, function(I) CC(sprintf("%x", rev(I))))
+     if(hasNA) hex[iNA] <- NA_character_
+     hex <- strsplit(hex, NULL)
+ 
+     db <- t(expand.grid(0:1,0:1,0:1,0:1, KEEP.OUT.ATTRS=FALSE)[,4:1])
+     storage.mode(db) <- "character" # "0" or "1"
+     dimnames(db) <- list(NULL, c(paste(0:9), letters[1:6]))
+     ## db is  4 x 16  matrix  with col.names "0" "1" .. "9" "a" "b" ... "f"
+ 
+     ex <- .expo(x)
+     if(is.matrix(ex))
+         ## 64-bit case: exponent is long == two ints
+         ## -----------  but currently the 2nd int is always 0 (or NA for '0')
+         ex <- ex[1,]
+     pat <- paste("(", sapply(pmax(0, ex),
+                              function(n) CC(rep.int(".", n))),
+                  ")0+$", sep="")
+     pat <- ifelse(iNA, NA_character_, pat)
+ 
+     if(hasNA) {
+ 	r <- as.list(iNA)
+ 	r[!iNA] <- lapply(hex[!iNA], function(ch) CC(as.vector(db[,ch])))
+ 	r[iNA ] <- NA_character_
+         ## now keep correct number of trailing zeros :
+         r[!iNA] <- lapply(which(!iNA), function(i) sub(pat[i], "\\1", r[[i]]))
+         unlist(r)
+     }
+     else {
+ 	r <- lapply(hex, function(ch) CC(as.vector(db[,ch])))
+         ## now keep correct number of trailing zeros :
+         sapply(seq_along(r), function(i) sub(pat[i], "\\1", r[[i]]))
+     }
+ 
+ }
> 
> x <- mpfr(c(3:5,11:15, 59, 125:127, 1025), 64)
> x
13 'mpfr' numbers of precision  64   bits 
 [1]    3    4    5   11   12   13   14   15   59  125  126  127 1025
> data.frame(x= as.numeric(x), I(Bits(x)))
      x     Bits.x.
1     3          11
2     4        <NA>
3     5         101
4    11        1011
5    12        1100
6    13        1101
7    14        1110
8    15        1111
9    59      111011
10  125     1111101
11  126     1111110
12  127     1111111
13 1025 10000000001
> 
> x <- mpfr(c(-20:30),64)
> x <- x[x != 0] # mpfr(0, *) has "random" bits
> data.frame(x= as.numeric(x), I(Bits(x)))
     x Bits.x.
1  -20   10100
2  -19   10011
3  -18   10010
4  -17   10001
5  -16    <NA>
6  -15    1111
7  -14    1110
8  -13    1101
9  -12    1100
10 -11    1011
11 -10    1010
12  -9    1001
13  -8    <NA>
14  -7     111
15  -6     110
16  -5     101
17  -4    <NA>
18  -3      11
19  -2    <NA>
20  -1    <NA>
21   1    <NA>
22   2    <NA>
23   3      11
24   4    <NA>
25   5     101
26   6     110
27   7     111
28   8    <NA>
29   9    1001
30  10    1010
31  11    1011
32  12    1100
33  13    1101
34  14    1110
35  15    1111
36  16    <NA>
37  17   10001
38  18   10010
39  19   10011
40  20   10100
41  21   10101
42  22   10110
43  23   10111
44  24   11000
45  25   11001
46  26   11010
47  27   11011
48  28   11100
49  29   11101
50  30   11110
> 
> ## pi, in varying number of bits :
> p. <- round(pi* 2^c(10,16,5*(4:8)))
> dput(p.)
c(3217, 205887, 3294199, 105414357, 3373259426, 107944301636, 
3454217652358)
> p <- c(mpfr(c(3217, 205887, 3294199, 105414357,
+               3373259426, 107944301636, 3454217652358), 64),
+        Const("pi", 64))
> Bits(p)
[1] "110010010001"                                                    
[2] "110010010000111111"                                              
[3] "1100100100001111110111"                                          
[4] "110010010000111111011010101"                                     
[5] "11001001000011111101101010100010"                                
[6] "1100100100001111110110101010001000100"                           
[7] "110010010000111111011010101000100010000110"                      
[8] "1100100100001111110110101010001000100001011010001100001000110101"
> 
> 
> cat('Time elapsed: ', proc.time(),'\n') # "stats"
Time elapsed:  1.248 0.068 1.455 0.001 0.006 
> 
> if(!interactive()) warnings()
NULL
> 
