## Trivial NAMESPACE - this works, whereas a sophisticated one with
## importsFrom(..) does not .. ?!?!

useDynLib(Rmpfr, .registration=TRUE)

## Export all names -- gives a CHECK warning about all the exported undocumented C symbols
# exportPattern(".")

exportClasses("mpfr1", "mpfr"
              , "mpfrArray"
              , "mpfrMatrix"

              , "atomicVector"
              , "array_or_vector"
              , "Mnumber"
)

export(
       ## ".Arith.codes"
       ## , ".Arith.mpfr.num"
       ## , ".Arith.num.mpfr"
       ## , ".Compare.codes"
       ## , ".Compare.codesRev"
       ## , ".Compare.mpfr.num"
       ## , ".Compare.num.mpfr"
       ## , ".Math.codes"
       ## , ".Math.gen"
       ## , ".Summary.codes"
       ## , ".abs.mpfr"
       ## , ".dimCheck"
       ## , ".getPrec"
       ".getSign"
       ## , ".mA.subAssign"
       ## , ".matmult.R"
       ## , ".mpfr.debug"
       ## , ".mpfr.negative"
       ## , ".mpfr.negative.R"
       ## , ".mpfr.repl"
       ## , ".mpfr.sign"
       ## , ".mpfr.subset"
       , ".mpfr2str"
       ## , ".mpfrA.subset"
       ## , ".mpfrVersion"
       ## , ".packageName"
       ## , ".print.mpfr"
       ## , ".requireCachedGenerics"
       ## .Call "Arith_d_mpfr"
       ## .Call "Arith_i_mpfr"
       ## .Call "Arith_mpfr"
       ## .Call "Arith_mpfr_d"
       ## .Call "Arith_mpfr_i"
       ## .Call "Compare_mpfr"
       ## .Call "Compare_mpfr_d"
       ## .Call "Compare_mpfr_i"
       , "Ai"
       , "Bernoulli"
       , "Const"
       , "Ei"
       , "Li2"
       ## .Call "Math_mpfr"
       ## .Call "R_mpfr_atan2"
       ## .Call "R_mpfr_beta"
       ## .Call "R_mpfr_choose"
       ## .Call "R_mpfr_fac"
       ## .Call "R_mpfr_get_default_prec"
       ## .Call "R_mpfr_get_version"
       ## .Call "R_mpfr_hypot"
       ## .Call "R_mpfr_is_finite"
       ## .Call "R_mpfr_is_infinite"
       ## .Call "R_mpfr_is_integer"
       ## .Call "R_mpfr_is_na"
       ## .Call "R_mpfr_is_zero"
       ## .Call "R_mpfr_jn"
       ## .Call "R_mpfr_lbeta"
       ## .Call "R_mpfr_poch"
       ## .Call "R_mpfr_round"
       ## .Call "R_mpfr_set_debug"
       ## .Call "R_mpfr_set_default_prec"
       ## .Call "R_mpfr_yn"
       ## .Call "Rmpfr_abs"
       ## .Call "Rmpfr_minus"
       ## .Call "Summary_mpfr"
       , "all.equal"
       , "aperm"
       , "as.vector"
       , "atan2"
       , "beta" , "lbeta"
       , "c.mpfr"
       , "cbind"
       , "chooseMpfr", "chooseMpfr.all"
       ## .Call "const_asMpfr"
       , "crossprod"
       ## .Call "d2mpfr1"
       ## .Call "d2mpfr1_list"
       , "erf" , "erfc"
       , "factorial"
       , "factorialMpfr"
       , "format"
       , "formatMpfr"
       , "getD"
       , "getPrec"
       , "hypot"
       , "integrateR"
       , "is.whole"
       , "j0" , "j1" , "jn"
       , "mean"
       , "mpfr"
       , "mpfr.is.0"
       , "mpfr.is.integer"
       , "mpfr2array"
       ## .Call "mpfr2d"
       ## .Call "mpfr2i"
       ## .Call "mpfr2str"
       , "mpfrArray"
       , "mpfrVersion"
       , "mpfr_default_prec"
       , "pmax", "pmin"
       , "pnorm"
       , "pochMpfr"
       , "print.integrate"
       , "print.mpfr"
       , "print.mpfr1"
       , "print.mpfrArray"
       ## .Call "print_mpfr"
       ## .Call "print_mpfr1"
       , "rbind"
       , "roundMpfr"
       , "seqMpfr"
       ## .Call "str2mpfr1_list"
       , "t"
       , "tcrossprod"
       , "toNum"
       , "unique"
       , "y0"
       , "y1"
       , "yn"
       , "zeta"
       )

exportMethods(
              ## "own generics":

              ## "other generics"
              "abs", "log", "sign"
              , "all.equal", "aperm"
              , "as.vector", "as.integer", "as.numeric"
              , "coerce", "coerce<-"
              , "cbind", "rbind"
              , "dim", "dim<-", "dimnames", "dimnames<-"
              , "atan2", "beta", "lbeta"
              , "factorial"
              , "is.finite", "is.infinite", "is.na", "is.nan"
              , "%*%", "crossprod", "tcrossprod", "t"
              , "format"
              , "mean", "pmax", "pmin"
              , "show", "unique"
)

## FIXME: replace with  exportMethods(...)
## export(".__NAMESPACE__."
       ## , ".__S3MethodsTable__."
       ## , ".__T__%*%:base"
       ## , ".__T__Arith:base"
       ## , ".__T__Compare:methods"
       ## , ".__T__Logic:base"
       ## , ".__T__Math2:methods"
       ## , ".__T__Math:base"
       ## , ".__T__Ops:base"
       ## , ".__T__Summary:base"

       ## Why don't these have to be exported?
       ## , ".__T__[:base"
       ## , ".__T__[<-:base"
       ## , ".__T__[[:base"

       ## , ".__T__abs:base"
       ## , ".__T__all.equal:base"
       ## , ".__T__aperm:base"
       ## , ".__T__as.integer:base"
       ## , ".__T__as.numeric:base"
       ## , ".__T__as.vector:base"
       ## , ".__T__atan2:base"
       ## , ".__T__beta:base"
       ## , ".__T__cbind:Rmpfr"
       ## , ".__T__coerce:methods"
       ## , ".__T__coerce<-:methods"
       ## , ".__T__crossprod:base"
       ## , ".__T__dim:base"
       ## , ".__T__dim<-:base"
       ## , ".__T__dimnames:base"
       ## , ".__T__dimnames<-:base"
       ## , ".__T__factorial:base"
       ## , ".__T__format:base"
       ## , ".__T__is.finite:base"
       ## , ".__T__is.infinite:base"
       ## , ".__T__is.na:base"
       ## , ".__T__is.nan:base"
       ## , ".__T__lbeta:base"
       ## , ".__T__log:base"
       ## , ".__T__mean:base"
       ## , ".__T__pmax:Rmpfr"
       ## , ".__T__pmin:Rmpfr"
       ## , ".__T__rbind:Rmpfr"
       ## , ".__T__show:methods"
       ## , ".__T__sign:base"
       ## , ".__T__t:base"
       ## , ".__T__tcrossprod:base"
       ## , ".__T__unique:base"
       ## )
